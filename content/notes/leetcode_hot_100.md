+++
title = "LeetCode Hot 100"
description = "LeetCode Hot 100 Problem List (Chinese & English)"
date = 2026-01-09
updated = 2026-01-09

[taxonomies]
tags = ["leetcode", "algorithm"]

[extra]
toc = true
+++

## 引言

LeetCode Hot 100 是 LeetCode 上最热门的 100 道题目，涵盖了算法和数据结构的核心知识点。这份清单作为刷题的参考和进度跟踪。

题目按 Hot 100 的原始顺序排列，每道题标注了难度等级（E=Easy, M=Medium, H=Hard）和主要技术点，方便快速定位和复习。

## 统计

- **总数**: 100 题
- **难度分布**: 
  - Easy: 约 20 题
  - Medium: 约 60 题  
  - Hard: 约 20 题
- **主要技术点**: 数组、链表、树、动态规划、回溯、双指针、滑动窗口、栈、队列、图等

## 题目列表

| No. | Done | ID | 难度 | 技术点 | Chinese | English |
| :---: | :---: | :---: | :---: | :--- | :--- | :--- |
| 1 | <input type='checkbox' checked> | 160 | E | 链表, 双指针 | [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) | [Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/) |
| 2 | <input type='checkbox' checked> | 236 | M | 二叉树, DFS | [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) | [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) |
| 3 | <input type='checkbox' checked> | 234 | E | 链表, 双指针, 快慢指针 | [回文链表](https://leetcode.cn/problems/palindrome-linked-list/) | [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) |
| 4 | <input type='checkbox' checked> | 739 | M | 栈, 单调栈 | [每日温度](https://leetcode.cn/problems/daily-temperatures/) | [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/) |
| 5 | <input type='checkbox' checked> | 226 | E | 二叉树, 递归 | [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/) | [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) |
| 6 | <input type='checkbox' checked> | 221 | M | 动态规划, 二维DP | [最大正方形](https://leetcode.cn/problems/maximal-square/) | [Maximal Square](https://leetcode.com/problems/maximal-square/) |
| 7 | <input type='checkbox' checked> | 215 | M | 堆, 快速选择 | [数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/) | [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/) |
| 8 | <input type='checkbox' checked> | 208 | M | Trie树, 前缀树 | [实现Trie(前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/) | [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) |
| 9 | <input type='checkbox'> | 207 | M | 图, 拓扑排序, DFS | [课程表](https://leetcode.cn/problems/course-schedule/) | [Course Schedule](https://leetcode.com/problems/course-schedule/) |
| 10 | <input type='checkbox'> | 206 | E | 链表, 递归, 迭代 | [反转链表](https://leetcode.cn/problems/reverse-linked-list/) | [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) |
| 11 | <input type='checkbox'> | 200 | M | 图, DFS, BFS, 并查集 | [岛屿数量](https://leetcode.cn/problems/number-of-islands/) | [Number of Islands](https://leetcode.com/problems/number-of-islands/) |
| 12 | <input type='checkbox'> | 198 | M | 动态规划 | [打家劫舍](https://leetcode.cn/problems/house-robber/) | [House Robber](https://leetcode.com/problems/house-robber/) |
| 13 | <input type='checkbox'> | 169 | E | 数组, 哈希表, 投票算法 | [多数元素](https://leetcode.cn/problems/majority-element/) | [Majority Element](https://leetcode.com/problems/majority-element/) |
| 14 | <input type='checkbox'> | 238 | M | 数组, 前缀积 | [除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/) | [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/) |
| 15 | <input type='checkbox'> | 155 | M | 栈, 设计 | [最小栈](https://leetcode.cn/problems/min-stack/) | [Min Stack](https://leetcode.com/problems/min-stack/) |
| 16 | <input type='checkbox'> | 152 | M | 动态规划, 数组 | [乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/) | [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/) |
| 17 | <input type='checkbox'> | 148 | M | 链表, 归并排序, 快慢指针 | [排序链表](https://leetcode.cn/problems/sort-list/) | [Sort List](https://leetcode.com/problems/sort-list/) |
| 18 | <input type='checkbox'> | 146 | M | 哈希表, 双向链表, LRU | [LRU缓存](https://leetcode.cn/problems/lru-cache/) | [LRU Cache](https://leetcode.com/problems/lru-cache/) |
| 19 | <input type='checkbox'> | 142 | M | 链表, 快慢指针, 数学 | [环形链表II](https://leetcode.cn/problems/linked-list-cycle-ii/) | [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) |
| 20 | <input type='checkbox'> | 141 | E | 链表, 快慢指针, 哈希表 | [环形链表](https://leetcode.cn/problems/linked-list-cycle/) | [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) |
| 21 | <input type='checkbox'> | 139 | M | 动态规划, 字符串 | [单词拆分](https://leetcode.cn/problems/word-break/) | [Word Break](https://leetcode.com/problems/word-break/) |
| 22 | <input type='checkbox'> | 136 | E | 位运算, 异或 | [只出现一次的数字](https://leetcode.cn/problems/single-number/) | [Single Number](https://leetcode.com/problems/single-number/) |
| 23 | <input type='checkbox'> | 647 | M | 字符串, 动态规划, 中心扩展 | [回文子串](https://leetcode.cn/problems/palindromic-substrings/) | [Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/) |
| 24 | <input type='checkbox'> | 128 | M | 数组, 哈希表, 并查集 | [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/) | [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/) |
| 25 | <input type='checkbox'> | 124 | H | 二叉树, DFS, 递归 | [二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/) | [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) |
| 26 | <input type='checkbox'> | 322 | M | 动态规划, 完全背包 | [零钱兑换](https://leetcode.cn/problems/coin-change/) | [Coin Change](https://leetcode.com/problems/coin-change/) |
| 27 | <input type='checkbox'> | 494 | M | 动态规划, 背包问题 | [目标和](https://leetcode.cn/problems/target-sum/) | [Target Sum](https://leetcode.com/problems/target-sum/) |
| 28 | <input type='checkbox'> | 461 | E | 位运算, 异或 | [汉明距离](https://leetcode.cn/problems/hamming-distance/) | [Hamming Distance](https://leetcode.com/problems/hamming-distance/) |
| 29 | <input type='checkbox'> | 448 | E | 数组, 哈希表, 原地算法 | [找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/) | [Find All Numbers Disappeared in an Array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/) |
| 30 | <input type='checkbox'> | 438 | M | 字符串, 滑动窗口, 哈希表 | [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) | [Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/) |
| 31 | <input type='checkbox'> | 437 | M | 二叉树, DFS, 前缀和 | [路径总和III](https://leetcode.cn/problems/path-sum-iii/) | [Path Sum III](https://leetcode.com/problems/path-sum-iii/) |
| 32 | <input type='checkbox'> | 416 | M | 动态规划, 背包问题 | [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/) | [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/) |
| 33 | <input type='checkbox'> | 406 | M | 数组, 贪心, 排序 | [根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/) | [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/) |
| 34 | <input type='checkbox'> | 399 | M | 图, DFS, 并查集 | [除法求值](https://leetcode.cn/problems/evaluate-division/) | [Evaluate Division](https://leetcode.com/problems/evaluate-division/) |
| 35 | <input type='checkbox'> | 394 | M | 字符串, 栈, 递归 | [字符串解码](https://leetcode.cn/problems/decode-string/) | [Decode String](https://leetcode.com/problems/decode-string/) |
| 36 | <input type='checkbox'> | 347 | M | 堆, 哈希表, 桶排序 | [前K个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) | [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) |
| 37 | <input type='checkbox'> | 338 | E | 位运算, 动态规划 | [比特位计数](https://leetcode.cn/problems/counting-bits/) | [Counting Bits](https://leetcode.com/problems/counting-bits/) |
| 38 | <input type='checkbox'> | 337 | M | 二叉树, 动态规划, DFS | [打家劫舍III](https://leetcode.cn/problems/house-robber-iii/) | [House Robber III](https://leetcode.com/problems/house-robber-iii/) |
| 39 | <input type='checkbox'> | 121 | E | 数组, 动态规划, 贪心 | [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/) | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) |
| 40 | <input type='checkbox'> | 312 | H | 动态规划, 区间DP | [戳气球](https://leetcode.cn/problems/burst-balloons/) | [Burst Balloons](https://leetcode.com/problems/burst-balloons/) |
| 41 | <input type='checkbox'> | 309 | M | 动态规划, 状态机 | [最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/) | [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/) |
| 42 | <input type='checkbox'> | 301 | H | 字符串, BFS, DFS, 回溯 | [删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/) | [Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/) |
| 43 | <input type='checkbox'> | 300 | M | 动态规划, 二分查找, 贪心 | [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) | [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) |
| 44 | <input type='checkbox'> | 297 | H | 二叉树, 序列化, 设计 | [二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/) | [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) |
| 45 | <input type='checkbox'> | 287 | M | 数组, 双指针, 快慢指针, 二分查找 | [寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) | [Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/) |
| 46 | <input type='checkbox'> | 283 | E | 数组, 双指针 | [移动零](https://leetcode.cn/problems/move-zeroes/) | [Move Zeroes](https://leetcode.com/problems/move-zeroes/) |
| 47 | <input type='checkbox'> | 279 | M | 动态规划, 数学, BFS | [完全平方数](https://leetcode.cn/problems/perfect-squares/) | [Perfect Squares](https://leetcode.com/problems/perfect-squares/) |
| 48 | <input type='checkbox'> | 253 | M | 堆, 贪心, 排序 | [会议室II](https://leetcode.cn/problems/meeting-rooms-ii/) | [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/) |
| 49 | <input type='checkbox'> | 240 | M | 数组, 二分查找, 分治 | [搜索二维矩阵II](https://leetcode.cn/problems/search-a-2d-matrix-ii/) | [Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/) |
| 50 | <input type='checkbox'> | 239 | H | 滑动窗口, 单调队列, 堆 | [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) | [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) |
| 51 | <input type='checkbox'> | 22 | M | 字符串, 回溯, DFS | [括号生成](https://leetcode.cn/problems/generate-parentheses/) | [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) |
| 52 | <input type='checkbox'> | 49 | M | 字符串, 哈希表, 排序 | [字母异位词分组](https://leetcode.cn/problems/group-anagrams/) | [Group Anagrams](https://leetcode.com/problems/group-anagrams/) |
| 53 | <input type='checkbox'> | 48 | M | 数组, 数学, 矩阵 | [旋转图像](https://leetcode.cn/problems/rotate-image/) | [Rotate Image](https://leetcode.com/problems/rotate-image/) |
| 54 | <input type='checkbox'> | 46 | M | 数组, 回溯 | [全排列](https://leetcode.cn/problems/permutations/) | [Permutations](https://leetcode.com/problems/permutations/) |
| 55 | <input type='checkbox'> | 42 | H | 数组, 双指针, 栈, 动态规划 | [接雨水](https://leetcode.cn/problems/trapping-rain-water/) | [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/) |
| 56 | <input type='checkbox'> | 39 | M | 数组, 回溯, DFS | [组合总和](https://leetcode.cn/problems/combination-sum/) | [Combination Sum](https://leetcode.com/problems/combination-sum/) |
| 57 | <input type='checkbox'> | 543 | E | 二叉树, DFS | [二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/) | [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) |
| 58 | <input type='checkbox'> | 34 | M | 数组, 二分查找 | [在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) | [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) |
| 59 | <input type='checkbox'> | 33 | M | 数组, 二分查找 | [搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) | [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/) |
| 60 | <input type='checkbox'> | 32 | H | 字符串, 动态规划, 栈 | [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/) | [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/) |
| 61 | <input type='checkbox'> | 31 | M | 数组, 双指针, 数学 | [下一个排列](https://leetcode.cn/problems/next-permutation/) | [Next Permutation](https://leetcode.com/problems/next-permutation/) |
| 62 | <input type='checkbox'> | 538 | M | 二叉树, DFS, BST | [把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) | [Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/) |
| 63 | <input type='checkbox'> | 23 | H | 链表, 分治, 堆, 归并排序 | [合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) | [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) |
| 64 | <input type='checkbox'> | 560 | M | 数组, 哈希表, 前缀和 | [和为K的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/) | [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) |
| 65 | <input type='checkbox'> | 21 | E | 链表, 递归, 迭代 | [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) |
| 66 | <input type='checkbox'> | 20 | E | 字符串, 栈 | [有效的括号](https://leetcode.cn/problems/valid-parentheses/) | [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) |
| 67 | <input type='checkbox'> | 19 | M | 链表, 双指针 | [删除链表的倒数第N个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) | [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) |
| 68 | <input type='checkbox'> | 17 | M | 字符串, 回溯, DFS | [电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/) | [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/) |
| 69 | <input type='checkbox'> | 15 | M | 数组, 双指针, 排序 | [三数之和](https://leetcode.cn/problems/3sum/) | [3Sum](https://leetcode.com/problems/3sum/) |
| 70 | <input type='checkbox'> | 11 | M | 数组, 双指针, 贪心 | [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) |
| 71 | <input type='checkbox'> | 10 | H | 字符串, 动态规划, 递归 | [正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/) | [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/) |
| 72 | <input type='checkbox'> | 5 | M | 字符串, 动态规划, 中心扩展 | [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/) | [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) |
| 73 | <input type='checkbox'> | 4 | H | 数组, 二分查找, 分治 | [寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/) | [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/) |
| 74 | <input type='checkbox'> | 3 | M | 字符串, 哈希表, 滑动窗口 | [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) |
| 75 | <input type='checkbox'> | 2 | M | 链表, 数学, 模拟 | [两数相加](https://leetcode.cn/problems/add-two-numbers/) | [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) |
| 76 | <input type='checkbox'> | 79 | M | 数组, 回溯, DFS | [单词搜索](https://leetcode.cn/problems/word-search/) | [Word Search](https://leetcode.com/problems/word-search/) |
| 77 | <input type='checkbox'> | 114 | M | 二叉树, 链表, DFS | [二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) | [Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) |
| 78 | <input type='checkbox'> | 621 | M | 数组, 贪心, 堆, 数学 | [任务调度器](https://leetcode.cn/problems/task-scheduler/) | [Task Scheduler](https://leetcode.com/problems/task-scheduler/) |
| 79 | <input type='checkbox'> | 617 | E | 二叉树, DFS, 递归 | [合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/) | [Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/) |
| 80 | <input type='checkbox'> | 105 | M | 二叉树, 数组, 哈希表, 分治 | [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |
| 81 | <input type='checkbox'> | 104 | E | 二叉树, DFS, BFS, 递归 | [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) |
| 82 | <input type='checkbox'> | 102 | M | 二叉树, BFS, 层序遍历 | [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/) | [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) |
| 83 | <input type='checkbox'> | 101 | E | 二叉树, DFS, BFS, 递归 | [对称二叉树](https://leetcode.cn/problems/symmetric-tree/) | [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) |
| 84 | <input type='checkbox'> | 98 | M | 二叉树, DFS, BST, 递归 | [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) | [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) |
| 85 | <input type='checkbox'> | 96 | M | 动态规划, 树, 数学 | [不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/) | [Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/) |
| 86 | <input type='checkbox'> | 94 | E | 二叉树, 栈, 递归, 中序遍历 | [二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) | [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/) |
| 87 | <input type='checkbox'> | 85 | H | 数组, 动态规划, 栈, 单调栈 | [最大矩形](https://leetcode.cn/problems/maximal-rectangle/) | [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/) |
| 88 | <input type='checkbox'> | 84 | H | 数组, 栈, 单调栈 | [柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) | [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) |
| 89 | <input type='checkbox'> | 1 | E | 数组, 哈希表 | [两数之和](https://leetcode.cn/problems/two-sum/) | [Two Sum](https://leetcode.com/problems/two-sum/) |
| 90 | <input type='checkbox'> | 78 | M | 数组, 回溯, 位运算 | [子集](https://leetcode.cn/problems/subsets/) | [Subsets](https://leetcode.com/problems/subsets/) |
| 91 | <input type='checkbox'> | 76 | H | 字符串, 滑动窗口, 哈希表, 双指针 | [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/) | [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/) |
| 92 | <input type='checkbox'> | 75 | M | 数组, 双指针, 排序, 三路快排 | [颜色分类](https://leetcode.cn/problems/sort-colors/) | [Sort Colors](https://leetcode.com/problems/sort-colors/) |
| 93 | <input type='checkbox'> | 72 | H | 字符串, 动态规划 | [编辑距离](https://leetcode.cn/problems/edit-distance/) | [Edit Distance](https://leetcode.com/problems/edit-distance/) |
| 94 | <input type='checkbox'> | 70 | E | 动态规划, 数学 | [爬楼梯](https://leetcode.cn/problems/climbing-stairs/) | [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/) |
| 95 | <input type='checkbox'> | 581 | M | 数组, 栈, 贪心 | [最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/) | [Shortest Unsorted Continuous Subarray](https://leetcode.com/problems/shortest-unsorted-continuous-subarray/) |
| 96 | <input type='checkbox'> | 64 | M | 数组, 动态规划 | [最小路径和](https://leetcode.cn/problems/minimum-path-sum/) | [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/) |
| 97 | <input type='checkbox'> | 62 | M | 动态规划, 组合数学 | [不同路径](https://leetcode.cn/problems/unique-paths/) | [Unique Paths](https://leetcode.com/problems/unique-paths/) |
| 98 | <input type='checkbox'> | 56 | M | 数组, 排序, 贪心 | [合并区间](https://leetcode.cn/problems/merge-intervals/) | [Merge Intervals](https://leetcode.com/problems/merge-intervals/) |
| 99 | <input type='checkbox'> | 55 | M | 数组, 贪心 | [跳跃游戏](https://leetcode.cn/problems/jump-game/) | [Jump Game](https://leetcode.com/problems/jump-game/) |
| 100 | <input type='checkbox'> | 53 | M | 数组, 动态规划, 分治, 贪心 | [最大子数组和](https://leetcode.cn/problems/maximum-subarray/) | [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/) |

## 详细题解

### 160. 相交链表

[LT.160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)

这道题的核心思想是使用两个指针分别遍历两个链表，当其中一个指针到达链表末尾时，将其指向另一个链表的头部，继续遍历。这样做的目的是消除两个链表长度不同的影响，让两个指针同时到达相交节点。

**关键洞察**：如果两个链表相交，设链表 A 的不相交部分长度为 a，链表 B 的不相交部分长度为 b，公共部分长度为 c。当指针 pa 遍历完 A 再遍历 B，指针 pb 遍历完 B 再遍历 A 时，两个指针会同时到达相交点，因为它们都走了 a + b + c 的长度。

**边界情况**：
- 如果两个链表不相交，两个指针最终都会变成 `null`，循环结束返回 `null`
- 如果其中一个链表为空，直接返回 `null`

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pa = headA;
        ListNode pb = headB;
        while (pa != pb) {
            pa = pa != null ? pa.next : headB;
            pb = pb != null ? pb.next : headA;
        }
        return pa;
    }
}
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

// time: O(m + n), m 和 n 分别是两个链表的长度
// space: O(1)
```

**为什么能保证找到交点或同时到达 null**：
- 如果相交：pa 走 a + c + b，pb 走 b + c + a，两者在交点相遇
- 如果不相交：pa 走 m + n，pb 走 n + m，两者同时到达 null

这是空间复杂度 O(1) 的最优解，相比使用哈希表存储已访问节点的 O(m + n) 空间解法更加优雅。

### 236. 二叉树的最近公共祖先

[LT.236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

这道题的核心思想是使用递归自底向上查找，通过 DFS 后序遍历的方式，让每个节点向上返回它是否包含目标节点 p 或 q。

**思考过程**：
1. **边界情况**：如果当前节点为 `null`，或者当前节点就是 `p` 或 `q`，直接返回当前节点
2. **递归查找**：分别在左子树和右子树中查找 p 和 q
3. **判断结果**：
   - 如果左右子树都找到了节点（`left != null && right != null`），说明当前节点就是 LCA（p 和 q 分别在左右子树）
   - 如果只有一边找到了，说明 p 和 q 都在那一边的子树中，返回那边找到的结果
   - 如果两边都没找到，返回 `null`

**关键洞察**：LCA 一定是第一个能让左右子树都返回非 null 的节点。如果只有一边返回非 null，说明 LCA 在那边的子树中；如果两边都返回非 null，当前节点就是 LCA。

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == root || q == root) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null) {
            return root;
        }
        return left != null ? left : right;
    }
}
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

// time: O(n), n 是树中节点的个数
// space: O(h), h 是树的高度，递归栈的深度
```

### 234. 回文链表

[LT.234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)

这道题的核心思想是使用快慢指针找到链表中点，然后反转后半部分，再比较前半部分和反转后的后半部分。

**思考过程**：
1. **使用快慢指针找到中点**：fast 每次走两步，slow 每次走一步
2. **反转后半部分链表**：从 `slow.next` 开始反转
3. **比较两部分**：前半部分和反转后的后半部分逐一比较

**关键点：快慢指针在不同长度下的位置**：
- **偶数长度**（如 `1->2->2->1`，4 个节点）：
  - fast 停在倒数第二个节点（第二个 2）
  - slow 停在第二个节点（第一个 2），即前半部分的最后一个节点
  - `slow.next` 是后半部分的起始节点（第二个 2）
  
- **奇数长度**（如 `1->2->3->2->1`，5 个节点）：
  - fast 停在最后一个节点（最后一个 1）
  - slow 停在中间节点（3），即前半部分的最后一个节点
  - `slow.next` 是后半部分的起始节点（第二个 2）
  - 中间节点不参与比较，这正是我们想要的

**为什么 `fast.next != null && fast.next.next != null`**：
- 这样保证 fast 能走两步时才继续
- 偶数长度时，fast 停在倒数第二个节点（`fast.next != null` 但 `fast.next.next == null`）
- 奇数长度时，fast 停在最后一个节点（`fast.next == null`）

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }
        // 使用快慢指针找到中点
        // slow 会停在前半部分的最后一个节点
        ListNode slow = head, fast = head;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next; // fast 走两步
            slow = slow.next;      // slow 走一步
        }
        // slow.next 是后半部分的起始节点
        ListNode p1 = head;
        ListNode p2 = reverse(slow.next); // 反转后半部分
        
        // 比较前半部分和反转后的后半部分
        while (p2 != null) {
            if (p1.val != p2.val) return false;
            p1 = p1.next;
            p2 = p2.next;
        }
        return true;
    }

    // 反转链表
    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode next = head.next; // 保存下一个节点
            head.next = prev;          // 反转当前节点
            prev = head;               // prev 前移
            head = next;               // head 前移
        }
        return prev;
    }
}
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

// time: O(n), n 是链表长度
// space: O(1), 只使用了常数额外空间
```

### 739. 每日温度

[LT.739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

这道题的核心思想是使用单调栈（单调递减栈）来找到每个温度右侧第一个比它高的温度。

**思考过程**：
1. **使用单调递减栈**：栈中存储索引，从栈底到栈顶对应的温度递减
2. **遍历温度数组**：对于每个温度，如果它比栈顶索引对应的温度高，说明找到了栈顶元素右侧第一个更高的温度
3. **更新答案**：计算索引差 `i - j`，即需要等待的天数
4. **维护单调性**：弹出所有比当前温度低的栈顶元素，然后压入当前索引

**关键洞察**：
- 栈中存储的是"等待答案"的索引
- 当遇到更高的温度时，可以为栈中所有比当前温度低的元素提供答案
- 因为栈是单调递减的，所以弹出的顺序是合理的（从栈顶开始）

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ans = new int[n];
        // 单调递减栈，存储索引（从栈底到栈顶对应的温度递减）
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            // 当栈不为空且当前温度高于栈顶索引对应的温度时
            // 说明找到了栈顶元素右侧第一个更高的温度
            while (!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {
                int j = stack.pop();
                ans[j] = i - j; // 计算等待天数
            }
            // 将当前索引压入栈（等待后续更高的温度）
            stack.push(i);
        }
        // 栈中剩余元素的 ans 保持为 0（没有更高的温度）
        return ans;
    }
}

// time: O(n), 每个元素最多进出栈一次
// space: O(n), 栈的空间最多为 n
```

### 226. 翻转二叉树

[LT.226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)

这道题的核心思想是使用递归自底向上翻转每个节点的左右子树。

**思考过程**：
1. **边界情况**：如果当前节点为 `null`，直接返回 `null`
2. **递归翻转**：先递归翻转左子树和右子树，得到翻转后的子树
3. **交换左右子树**：将翻转后的左子树赋给右子树，翻转后的右子树赋给左子树
4. **返回当前节点**：返回翻转后的根节点

**关键洞察**：翻转二叉树就是翻转每个节点的左右子树。递归地先翻转子树，再交换当前节点的左右子树，自然就能翻转整棵树。

**变量命名改进**：使用 `invertedLeft` 和 `invertedRight` 能更清晰地表达这些是翻转后的子树，避免与 `root.left`、`root.right` 混淆。

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        // 递归翻转左右子树
        TreeNode invertedLeft = invertTree(root.left);
        TreeNode invertedRight = invertTree(root.right);
        // 交换左右子树
        root.left = invertedRight;
        root.right = invertedLeft;
        return root;
    }
}
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

// time: O(n), n 是树中节点的个数
// space: O(h), h 是树的高度，递归栈的深度
```

### 221. 最大正方形

[LT.221. Maximal Square](https://leetcode.com/problems/maximal-square/)

这道题的核心思想是使用动态规划（二维 DP）来找到矩阵中最大的由 '1' 组成的正方形。

**思考过程**：
1. **定义状态**：`dp[i][j]` 表示以 `matrix[i-1][j-1]` 为右下角的最大正方形的边长
2. **使用 (i+1, j+1) 索引**：为了避免边界判断，dp 数组使用 (m+1) x (n+1) 大小
3. **状态转移**：如果当前位置是 '1'，取上方、左方、左上方三个方向的最小值再加 1
4. **更新最大值**：遍历过程中记录最大边长
5. **返回面积**：返回 `maxSide * maxSide`

**关键洞察 - 为什么用 min**：
- 要形成一个 `k x k` 的正方形，需要上方、左方、左上方三个方向都能形成至少 `(k-1) x (k-1)` 的正方形
- 取三者最小值，相当于取三个方向中能扩展的最小"半径"
- 类似于木桶效应：最短的板决定了桶的容量

**技术要点**：
- **二维 DP**：使用二维数组存储子问题结果
- **最优子结构**：以某个位置为右下角的正方形大小依赖于其上方、左方、左上方的结果
- **边界处理**：使用 (m+1) x (n+1) 的 dp 数组，让索引从 1 开始，避免边界判断

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int m = matrix.length;
        if (m == 0) return 0;
        int n = matrix[0].length;
        // dp[i][j] 表示以 matrix[i-1][j-1] 为右下角的最大正方形的边长
        // 使用 (m+1) x (n+1) 大小，让索引从 1 开始，避免边界判断
        int[][] dp = new int[m + 1][n + 1];
        int maxSide = 0; // 记录最大边长

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (matrix[i - 1][j - 1] == '1') {
                    // 取上方、左方、左上方三个方向的最小值
                    // 因为要形成 k x k 正方形，三个方向都必须至少能形成 (k-1) x (k-1) 正方形
                    dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
                    maxSide = Math.max(dp[i][j], maxSide); // 更新最大边长
                }
                // 如果 matrix[i-1][j-1] == '0'，dp[i][j] 保持为 0
            }
        }

        return maxSide * maxSide; // 返回面积
    }
}

// time: O(m * n), m 和 n 分别是矩阵的行数和列数
// space: O(m * n), dp 数组的空间
```

### 215. 数组中的第K个最大元素

[LT.215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)

这道题有两种主要解法：最小堆和快速选择（Quick Select）。快速选择使用三路分区（Three-Way Partition）可以高效处理重复元素。

**思考过程**：
1. **最小堆方法**：维护大小为 k 的最小堆，堆顶即为第 k 大元素
2. **快速选择方法**：使用 partition 将数组分成三部分，根据 pivot 位置决定递归方向
3. **三路分区的优势**：当数组中有大量重复元素时，标准分区会导致 TLE，三路分区可以高效处理

#### 方法一：最小堆（推荐，简单稳定）

**核心思想**：维护大小为 k 的最小堆，堆中存储当前见过的 k 个最大元素，堆顶即为第 k 大元素。

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 最小堆（默认 PriorityQueue 是最小堆）
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        
        for (int num : nums) {
            pq.offer(num);
            // 保持堆大小为 k，移除最小的元素
            if (pq.size() > k) {
                pq.poll();
            }
        }
        
        return pq.peek(); // 堆顶 = 第 k 大元素
    }
}

// time: O(n log k), n 是数组长度
// space: O(k), 堆的空间
```

#### 方法二：快速选择 + 三路分区（处理重复元素）

##### 为什么需要三路分区？

标准分区（两路分区）在遇到重复元素时会退化：
- 当所有元素相等时，标准分区会把所有元素分到一边
- 每次递归只减少一个元素 → O(n²) 时间复杂度 → TLE

**三路分区**将数组分成三部分：`[< pivot] [= pivot] [> pivot]`，当所有元素相等时可以直接返回，避免递归。

##### 三路分区详解（Dutch National Flag Algorithm）

**核心思想**：使用三个指针将数组分成三个区域（实现中将 pivot 交换到 left 位置）：
- `lt`: `[left+1, lt-1]` 是 `< pivot` 的区域（lt 指向第一个 `= pivot` 的位置）
- `i`: 当前扫描指针，`[i, gt]` 是未处理的区域
- `gt`: `[gt+1, right]` 是 `> pivot` 的区域（gt 指向最后一个 `= pivot` 的位置）
- 分区后：`[lt, gt]` 是 `= pivot` 的区域（闭区间）

**分区过程**：
1. **随机选择 pivot** 并交换到 `left` 位置（简化逻辑）
2. 如果 `nums[i] < pivot`: 交换到左区域，`i++`, `lt++`
3. 如果 `nums[i] = pivot`: 已经在正确位置，`i++`
4. 如果 `nums[i] > pivot`: 交换到右区域，`gt--`（不移动 `i`，需要检查交换来的元素）

**详细示例**：

```
Array: [3, 2, 3, 1, 3, 4, 5, 3], pivot = 3

初始状态：i=0, j=0, k=7, pivot=3
[3, 2, 3, 1, 3, 4, 5, 3]
 ↑
 i,j                     k

j=0: nums[0]=3 = pivot, j++
[3, 2, 3, 1, 3, 4, 5, 3]
 ↑  ↑
 i  j                  k

j=1: nums[1]=2 < pivot, swap(i,j), i++, j++
[2, 3, 3, 1, 3, 4, 5, 3]
    ↑  ↑
    i  j               k

j=2: nums[2]=3 = pivot, j++
[2, 3, 3, 1, 3, 4, 5, 3]
    ↑     ↑
    i     j            k

j=3: nums[3]=1 < pivot, swap(i,j), i++, j++
[2, 1, 3, 3, 3, 4, 5, 3]
       ↑  ↑
       i  j            k

j=4: nums[4]=3 = pivot, j++
[2, 1, 3, 3, 3, 4, 5, 3]
       ↑     ↑
       i     j         k

j=5: nums[5]=4 > pivot, swap(j,k), k--
[2, 1, 3, 3, 3, 3, 5, 4]
       ↑     ↑     ↑
       i     j     k
注意：j 不移动，需要检查交换来的元素

j=5: nums[5]=3 = pivot, j++
[2, 1, 3, 3, 3, 3, 5, 4]
       ↑        ↑  ↑
       i        j  k

j=6: nums[6]=5 > pivot, swap(j,k), k--
[2, 1, 3, 3, 3, 3, 4, 5]
       ↑        ↑  ↑
       i        j  k

j=6: nums[6]=4 > pivot, swap(j,k), k--
[2, 1, 3, 3, 3, 3, 5, 4]
       ↑        ↑  ↑
       i        j  k
但此时 j=6 > k=5，循环结束

最终交换 pivot (nums[right]=3) 到位置 j
[2, 1, 3, 3, 3, 3, 5, 4] → [2, 1, 3, 3, 3, 3, 4, 5]
                              ↑        ↑     ↑
                            i=2        j=6  (pivot最终位置)

返回 [i=2, j=6]，表示 [2,6] 范围内的元素都等于 pivot（闭区间，两端都包含）
```

##### 完整代码实现

**实现要点**：
- 使用**随机 pivot**避免最坏情况
- 将 pivot 交换到 `left` 位置，简化分区逻辑
- 使用迭代而非递归，空间更优
- 三指针分区：`lt`（小于区域边界）、`i`（扫描指针）、`gt`（大于区域边界）

```java
class Solution {
    private final Random random = new Random();
   
    public int findKthLargest(int[] nums, int k) {
        int n = nums.length;
        // 将第 k 大转换为第 (n-k) 小（0-indexed）
        int target = n - k;
        int left = 0, right = n - 1;
        
        // 迭代版本的快速选择（避免递归栈空间）
        while (left <= right) {
            // 三路分区，返回等于 pivot 的范围 [lt, gt]（闭区间）
            int[] p = partition3(nums, left, right);
            int lt = p[0]; // 等于 pivot 区域的起始索引
            int gt = p[1]; // 等于 pivot 区域的结束索引
            
            if (target < lt) {
                // target 在左半部分（< pivot）
                right = lt - 1;
            } else if (target > gt) {
                // target 在右半部分（> pivot）
                left = gt + 1;
            } else {
                // target 在等于 pivot 的范围内，找到了！
                return nums[lt];
            }
        }
        return -1; // 不应该到达这里
    }

    // 三路分区（Dutch National Flag Algorithm）
    // 将数组分成三部分：[< pivot] [= pivot] [> pivot]
    // 返回：等于 pivot 的元素的起始和结束位置 [lt, gt]（闭区间）
    private int[] partition3(int[] nums, int left, int right) {
        // 随机选择 pivot，避免最坏情况
        int pivotIndex = left + random.nextInt(right - left + 1);
        int pivot = nums[pivotIndex];
        
        // 将 pivot 交换到 left 位置，简化分区逻辑
        swap(nums, left, pivotIndex);
        
        // 初始化三个指针：
        // lt: [left+1, lt-1] 是 < pivot 的区域（lt 指向第一个 = pivot 的位置）
        // i:  扫描指针，当前检查的位置
        // gt: [gt+1, right] 是 > pivot 的区域（gt 指向最后一个 = pivot 的位置）
        int lt = left;        // 小于区域的右边界（不包含），等于区域的起始位置
        int i = left + 1;     // 当前扫描位置，从 left+1 开始
        int gt = right;       // 大于区域的左边界（不包含），等于区域的结束位置
        
        // 扫描未处理的区域 [i, gt]
        while (i <= gt) {
            if (nums[i] < pivot) {
                // 小于 pivot：交换到左区域
                // 交换后，nums[lt] 是之前的小元素，nums[i] 是原来 lt 位置的值
                // lt++ 和 i++ 都移动，因为交换后 i 位置的值已经处理过
                swap(nums, i++, lt++);
            } else if (nums[i] > pivot) {
                // 大于 pivot：交换到右区域
                // 交换后，nums[gt] 是之前的大元素，nums[i] 是交换来的未知值
                // 只移动 gt--，i 不移动，因为需要检查交换来的元素
                swap(nums, i, gt--);
            } else {
                // 等于 pivot：已经在正确位置，继续扫描
                i++;
            }
        }
        
        // 分区完成后的状态：
        // [left+1, lt-1] 是 < pivot 的元素
        // [lt, gt] 是 = pivot 的元素（闭区间）
        // [gt+1, right] 是 > pivot 的元素
        // 注意：left 位置的 pivot 在分区过程中被交换到 [lt, gt] 范围内的某个位置
        
        // 返回等于 pivot 的范围（闭区间）
        return new int[]{lt, gt};
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}

// time: O(n) 平均时间，O(n²) 最坏情况（但三路分区使最坏情况很少发生）
// space: O(1) 额外空间，递归栈 O(log n) 平均，O(n) 最坏
```

##### 为什么三路分区能处理重复元素？

**场景：所有元素相等** `[5, 5, 5, 5, 5]`, k = 3

1. 三路分区后：所有元素都在 `= pivot` 区域
2. 返回范围 `[0, 4]`（闭区间）
3. k=2 在范围内（0 <= 2 <= 4）→ 直接返回，无需递归！

**为什么使用 `k <= pivotEnd` 而不是 `k < pivotEnd`？**

关键原因：三路分区返回的范围是**闭区间** `[pivotStart, pivotEnd]`，两端都包含。

**详细解释**：
1. 循环结束后，`j` 指向第一个 `> pivot` 区域的位置（或 `j = k+1`，此时所有元素已处理）
2. 我们执行 `swap(nums, j, right)`，将 pivot（原来在 `nums[right]`）交换到位置 `j`
3. **交换后，`nums[j]` 也等于 pivot**
4. 所以 `[i, j]` 范围内的所有元素（包括索引 `j`）都等于 pivot
5. 因此判断时必须使用 `k <= pivotEnd` 来包含索引 `pivotEnd`（即 `j`）本身

**示例验证**：
```
分区后：[2, 1, 3, 3, 3, 3, 4, 5]
        < pivot    = pivot    > pivot
索引：   0  1  2  3  4  5  6  7
                    ↑        ↑
                  i=2      j=6 (pivotEnd)

返回 [2, 6]，表示索引 2 到 6（包含）都等于 pivot
如果 k=6，应该被包含在范围内，所以需要 k <= 6
```

**对比标准分区**：
- 标准分区：所有元素分到一边，每次只减少一个元素 → O(n²)
- 三路分区：所有相等的元素被识别为一个整体，立即返回 → O(n)

##### 复杂度分析

- **时间复杂度**：
  - 平均：O(n) - 每次分区大约消除一半元素
  - 最坏：O(n²) - 但三路分区使最坏情况很少发生（所有元素相等时是 O(n)）
- **空间复杂度**：O(1) 额外空间，递归栈 O(log n) 平均

##### 方法选择建议

- **面试/实践**：优先使用最小堆，简单稳定，易于解释
- **学习算法**：实现三路分区，理解分区思想
- **性能优化**：三路分区在重复元素多时更优

### 208. 实现Trie(前缀树)

[LT.208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)

Trie（前缀树）是一种树形数据结构，用于高效存储和检索字符串集合。它的核心思想是利用字符串的公共前缀来减少存储空间，并支持快速的前缀匹配。

**思考过程**：
1. **节点结构**：每个节点包含一个子节点数组（26个字母）和一个布尔标志（表示是否为单词结尾）
2. **插入操作**：从根节点开始，沿着字符路径创建节点，到达单词末尾时标记为结束
3. **查找操作**：从根节点开始，沿着字符路径查找，检查是否存在完整的单词或前缀
4. **辅助方法**：`find` 方法统一处理路径查找，`search` 和 `startsWith` 复用该方法

**核心思想**：
- **共享前缀**：具有相同前缀的单词共享路径，节省空间
- **路径表示字符**：从根到某个节点的路径表示一个字符串前缀
- **结束标志**：`isEnd` 标志区分完整单词和前缀

```java
class Trie {
    // 根节点（不存储字符，作为所有单词的起始点）
    private final TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    // 插入单词到 Trie 中
    public void insert(String word) {
        TrieNode cur = root;
        // 沿着单词的每个字符路径向下
        for (char c : word.toCharArray()) {
            int idx = c - 'a'; // 将字符转换为索引（'a'=0, 'b'=1, ...）
            // 如果当前字符对应的子节点不存在，创建新节点
            if (cur.children[idx] == null) {
                cur.children[idx] = new TrieNode();
            }
            // 移动到子节点
            cur = cur.children[idx];
        }
        // 标记单词结束
        cur.isEnd = true;
    }
    
    // 查找完整的单词（必须是一个完整的单词，不能只是前缀）
    public boolean search(String word) {
        TrieNode node = find(word);
        // 找到节点且该节点标记为单词结尾
        return node != null && node.isEnd;
    }
    
    // 检查是否存在以给定前缀开头的单词
    public boolean startsWith(String prefix) {
        // 只要找到对应的节点路径即可（不需要是完整单词）
        return find(prefix) != null;
    }

    // 辅助方法：查找字符串对应的节点
    // 如果路径存在返回对应节点，否则返回 null
    private TrieNode find(String s) {
        TrieNode cur = root;
        for (char c : s.toCharArray()) {
            int idx = c - 'a';
            // 如果路径中断，返回 null
            if (cur.children[idx] == null) return null;
            cur = cur.children[idx];
        }
        return cur;
    }

    // Trie 节点定义
    private static class TrieNode {
        // 子节点数组，每个索引对应一个字母（'a' 到 'z'）
        private TrieNode[] children = new TrieNode[26];
        // 标记当前节点是否为某个单词的结尾
        private boolean isEnd = false;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */

// 时间复杂度：
//   insert: O(m), m 是单词长度
//   search: O(m), m 是单词长度
//   startsWith: O(m), m 是前缀长度
// 空间复杂度：O(ALPHABET_SIZE × N × M)，N 是单词数量，M 是平均单词长度
```
